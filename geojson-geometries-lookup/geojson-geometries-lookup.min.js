'use strict';
function _classCallCheck(e, t) {
	if (!_instanceof(e, t)) throw new TypeError('Cannot call a class as a function');
}
function _defineProperties(e, t) {
	for (var r = 0; r < t.length; r++) {
		var n = t[r];
		(n.enumerable = n.enumerable || !1),
			(n.configurable = !0),
			'value' in n && (n.writable = !0),
			Object.defineProperty(e, n.key, n);
	}
}
function _createClass(e, t, r) {
	return t && _defineProperties(e.prototype, t), r && _defineProperties(e, r), e;
}
function _typeof(e) {
	return (_typeof =
		'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator
			? function(e) {
					return typeof e;
			  }
			: function(e) {
					return e && 'function' == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype
						? 'symbol'
						: typeof e;
			  })(e);
}
function _instanceof(e, t) {
	return null != t && 'undefined' != typeof Symbol && t[Symbol.hasInstance]
		? !!t[Symbol.hasInstance](e)
		: e instanceof t;
}
var geometriesLookup = (function() {
	var e =
		'undefined' != typeof globalThis
			? globalThis
			: 'undefined' != typeof window
			? window
			: 'undefined' != typeof global
			? global
			: 'undefined' != typeof self
			? self
			: {};
	function t(e) {
		return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, 'default') ? e.default : e;
	}
	function r(e, t) {
		return e((t = { exports: {} }), t.exports), t.exports;
	}
	var n = r(function(e, t) {
			e.exports = (function() {
				function e(e, t, r) {
					var n = e[t];
					(e[t] = e[r]), (e[r] = n);
				}
				function t(e, t) {
					return e < t ? -1 : e > t ? 1 : 0;
				}
				return function(r, n, o, i, a) {
					!(function t(r, n, o, i, a) {
						for (; i > o; ) {
							if (i - o > 600) {
								var u = i - o + 1,
									s = n - o + 1,
									l = Math.log(u),
									c = 0.5 * Math.exp((2 * l) / 3),
									f = 0.5 * Math.sqrt((l * c * (u - c)) / u) * (s - u / 2 < 0 ? -1 : 1),
									h = Math.max(o, Math.floor(n - (s * c) / u + f)),
									d = Math.min(i, Math.floor(n + ((u - s) * c) / u + f));
								t(r, n, h, d, a);
							}
							var g = r[n],
								m = o,
								p = i;
							for (e(r, o, n), a(r[i], g) > 0 && e(r, o, i); m < p; ) {
								for (e(r, m, p), m++, p--; a(r[m], g) < 0; ) m++;
								for (; a(r[p], g) > 0; ) p--;
							}
							0 === a(r[o], g) ? e(r, o, p) : e(r, ++p, i), p <= n && (o = p + 1), n <= p && (i = p - 1);
						}
					})(r, n, o || 0, i || r.length - 1, a || t);
				};
			})();
		}),
		o = a,
		i = a;
	function a(e, t) {
		if (!_instanceof(this, a)) return new a(e, t);
		(this._maxEntries = Math.max(4, e || 9)),
			(this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
			t && this._initFormat(t),
			this.clear();
	}
	function u(e, t, r) {
		if (!r) return t.indexOf(e);
		for (var n = 0; n < t.length; n++) if (r(e, t[n])) return n;
		return -1;
	}
	function s(e, t) {
		l(e, 0, e.children.length, t, e);
	}
	function l(e, t, r, n, o) {
		o || (o = y(null)), (o.minX = 1 / 0), (o.minY = 1 / 0), (o.maxX = -1 / 0), (o.maxY = -1 / 0);
		for (var i, a = t; a < r; a++) (i = e.children[a]), c(o, e.leaf ? n(i) : i);
		return o;
	}
	function c(e, t) {
		return (
			(e.minX = Math.min(e.minX, t.minX)),
			(e.minY = Math.min(e.minY, t.minY)),
			(e.maxX = Math.max(e.maxX, t.maxX)),
			(e.maxY = Math.max(e.maxY, t.maxY)),
			e
		);
	}
	function f(e, t) {
		return e.minX - t.minX;
	}
	function h(e, t) {
		return e.minY - t.minY;
	}
	function d(e) {
		return (e.maxX - e.minX) * (e.maxY - e.minY);
	}
	function g(e) {
		return e.maxX - e.minX + (e.maxY - e.minY);
	}
	function m(e, t) {
		return e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY;
	}
	function p(e, t) {
		return t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY;
	}
	function y(e) {
		return { children: e, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
	}
	function v(e, t, r, o, i) {
		for (var a, u = [t, r]; u.length; )
			(r = u.pop()) - (t = u.pop()) <= o ||
				((a = t + Math.ceil((r - t) / o / 2) * o), n(e, a, t, r, i), u.push(t, a, a, r));
	}
	(a.prototype = {
		all: function() {
			return this._all(this.data, []);
		},
		search: function(e) {
			var t = this.data,
				r = [],
				n = this.toBBox;
			if (!p(e, t)) return r;
			for (var o, i, a, u, s = []; t; ) {
				for (o = 0, i = t.children.length; o < i; o++)
					(a = t.children[o]),
						p(e, (u = t.leaf ? n(a) : a)) && (t.leaf ? r.push(a) : m(e, u) ? this._all(a, r) : s.push(a));
				t = s.pop();
			}
			return r;
		},
		collides: function(e) {
			var t = this.data,
				r = this.toBBox;
			if (!p(e, t)) return !1;
			for (var n, o, i, a, u = []; t; ) {
				for (n = 0, o = t.children.length; n < o; n++)
					if (((i = t.children[n]), p(e, (a = t.leaf ? r(i) : i)))) {
						if (t.leaf || m(e, a)) return !0;
						u.push(i);
					}
				t = u.pop();
			}
			return !1;
		},
		load: function(e) {
			if (!e || !e.length) return this;
			if (e.length < this._minEntries) {
				for (var t = 0, r = e.length; t < r; t++) this.insert(e[t]);
				return this;
			}
			var n = this._build(e.slice(), 0, e.length - 1, 0);
			if (this.data.children.length)
				if (this.data.height === n.height) this._splitRoot(this.data, n);
				else {
					if (this.data.height < n.height) {
						var o = this.data;
						(this.data = n), (n = o);
					}
					this._insert(n, this.data.height - n.height - 1, !0);
				}
			else this.data = n;
			return this;
		},
		insert: function(e) {
			return e && this._insert(e, this.data.height - 1), this;
		},
		clear: function() {
			return (this.data = y([])), this;
		},
		remove: function(e, t) {
			if (!e) return this;
			for (var r, n, o, i, a = this.data, s = this.toBBox(e), l = [], c = []; a || l.length; ) {
				if (
					(a || ((a = l.pop()), (n = l[l.length - 1]), (r = c.pop()), (i = !0)),
					a.leaf && -1 !== (o = u(e, a.children, t)))
				)
					return a.children.splice(o, 1), l.push(a), this._condense(l), this;
				i || a.leaf || !m(a, s)
					? n
						? (r++, (a = n.children[r]), (i = !1))
						: (a = null)
					: (l.push(a), c.push(r), (r = 0), (n = a), (a = a.children[0]));
			}
			return this;
		},
		toBBox: function(e) {
			return e;
		},
		compareMinX: f,
		compareMinY: h,
		toJSON: function() {
			return this.data;
		},
		fromJSON: function(e) {
			return (this.data = e), this;
		},
		_all: function(e, t) {
			for (var r = []; e; ) e.leaf ? t.push.apply(t, e.children) : r.push.apply(r, e.children), (e = r.pop());
			return t;
		},
		_build: function(e, t, r, n) {
			var o,
				i = r - t + 1,
				a = this._maxEntries;
			if (i <= a) return s((o = y(e.slice(t, r + 1))), this.toBBox), o;
			n || ((n = Math.ceil(Math.log(i) / Math.log(a))), (a = Math.ceil(i / Math.pow(a, n - 1)))),
				((o = y([])).leaf = !1),
				(o.height = n);
			var u,
				l,
				c,
				f,
				h = Math.ceil(i / a),
				d = h * Math.ceil(Math.sqrt(a));
			for (v(e, t, r, d, this.compareMinX), u = t; u <= r; u += d)
				for (v(e, u, (c = Math.min(u + d - 1, r)), h, this.compareMinY), l = u; l <= c; l += h)
					(f = Math.min(l + h - 1, c)), o.children.push(this._build(e, l, f, n - 1));
			return s(o, this.toBBox), o;
		},
		_chooseSubtree: function(e, t, r, n) {
			for (var o, i, a, u, s, l, c, f, h, g; n.push(t), !t.leaf && n.length - 1 !== r; ) {
				for (c = f = 1 / 0, o = 0, i = t.children.length; o < i; o++)
					(s = d((a = t.children[o]))),
						(h = e),
						(g = a),
						(l =
							(Math.max(g.maxX, h.maxX) - Math.min(g.minX, h.minX)) *
								(Math.max(g.maxY, h.maxY) - Math.min(g.minY, h.minY)) -
							s) < f
							? ((f = l), (c = s < c ? s : c), (u = a))
							: l === f && s < c && ((c = s), (u = a));
				t = u || t.children[0];
			}
			return t;
		},
		_insert: function(e, t, r) {
			var n = this.toBBox,
				o = r ? e : n(e),
				i = [],
				a = this._chooseSubtree(o, this.data, t, i);
			for (a.children.push(e), c(a, o); t >= 0 && i[t].children.length > this._maxEntries; )
				this._split(i, t), t--;
			this._adjustParentBBoxes(o, i, t);
		},
		_split: function(e, t) {
			var r = e[t],
				n = r.children.length,
				o = this._minEntries;
			this._chooseSplitAxis(r, o, n);
			var i = this._chooseSplitIndex(r, o, n),
				a = y(r.children.splice(i, r.children.length - i));
			(a.height = r.height),
				(a.leaf = r.leaf),
				s(r, this.toBBox),
				s(a, this.toBBox),
				t ? e[t - 1].children.push(a) : this._splitRoot(r, a);
		},
		_splitRoot: function(e, t) {
			(this.data = y([e, t])),
				(this.data.height = e.height + 1),
				(this.data.leaf = !1),
				s(this.data, this.toBBox);
		},
		_chooseSplitIndex: function(e, t, r) {
			var n, o, i, a, u, s, c, f, h, g, m, p, y, v;
			for (s = c = 1 / 0, n = t; n <= r - t; n++)
				(o = l(e, 0, n, this.toBBox)),
					(i = l(e, n, r, this.toBBox)),
					(h = o),
					(g = i),
					(m = void 0),
					(p = void 0),
					(y = void 0),
					(v = void 0),
					(m = Math.max(h.minX, g.minX)),
					(p = Math.max(h.minY, g.minY)),
					(y = Math.min(h.maxX, g.maxX)),
					(v = Math.min(h.maxY, g.maxY)),
					(a = Math.max(0, y - m) * Math.max(0, v - p)),
					(u = d(o) + d(i)),
					a < s ? ((s = a), (f = n), (c = u < c ? u : c)) : a === s && u < c && ((c = u), (f = n));
			return f;
		},
		_chooseSplitAxis: function(e, t, r) {
			var n = e.leaf ? this.compareMinX : f,
				o = e.leaf ? this.compareMinY : h;
			this._allDistMargin(e, t, r, n) < this._allDistMargin(e, t, r, o) && e.children.sort(n);
		},
		_allDistMargin: function(e, t, r, n) {
			e.children.sort(n);
			var o,
				i,
				a = this.toBBox,
				u = l(e, 0, t, a),
				s = l(e, r - t, r, a),
				f = g(u) + g(s);
			for (o = t; o < r - t; o++) (i = e.children[o]), c(u, e.leaf ? a(i) : i), (f += g(u));
			for (o = r - t - 1; o >= t; o--) (i = e.children[o]), c(s, e.leaf ? a(i) : i), (f += g(s));
			return f;
		},
		_adjustParentBBoxes: function(e, t, r) {
			for (var n = r; n >= 0; n--) c(t[n], e);
		},
		_condense: function(e) {
			for (var t, r = e.length - 1; r >= 0; r--)
				0 === e[r].children.length
					? r > 0
						? (t = e[r - 1].children).splice(t.indexOf(e[r]), 1)
						: this.clear()
					: s(e[r], this.toBBox);
		},
		_initFormat: function(e) {
			var t = ['return a', ' - b', ';'];
			(this.compareMinX = new Function('a', 'b', t.join(e[0]))),
				(this.compareMinY = new Function('a', 'b', t.join(e[1]))),
				(this.toBBox = new Function(
					'a',
					'return {minX: a' + e[0] + ', minY: a' + e[1] + ', maxX: a' + e[2] + ', maxY: a' + e[3] + '};'
				));
		},
	}),
		(o.default = i);
	var b = r(function(e, t) {
		function r(e, t, r) {
			void 0 === r && (r = {});
			var n = { type: 'Feature' };
			return (
				(0 === r.id || r.id) && (n.id = r.id),
				r.bbox && (n.bbox = r.bbox),
				(n.properties = t || {}),
				(n.geometry = e),
				n
			);
		}
		function n(e, t, n) {
			return void 0 === n && (n = {}), r({ type: 'Point', coordinates: e }, t, n);
		}
		function o(e, t, n) {
			void 0 === n && (n = {});
			for (var o = 0, i = e; o < i.length; o++) {
				var a = i[o];
				if (a.length < 4) throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
				for (var u = 0; u < a[a.length - 1].length; u++)
					if (a[a.length - 1][u] !== a[0][u]) throw new Error('First and last Position are not equivalent.');
			}
			return r({ type: 'Polygon', coordinates: e }, t, n);
		}
		function i(e, t, n) {
			if ((void 0 === n && (n = {}), e.length < 2))
				throw new Error('coordinates must be an array of two or more positions');
			return r({ type: 'LineString', coordinates: e }, t, n);
		}
		function a(e, t) {
			void 0 === t && (t = {});
			var r = { type: 'FeatureCollection' };
			return t.id && (r.id = t.id), t.bbox && (r.bbox = t.bbox), (r.features = e), r;
		}
		function u(e, t, n) {
			return void 0 === n && (n = {}), r({ type: 'MultiLineString', coordinates: e }, t, n);
		}
		function s(e, t, n) {
			return void 0 === n && (n = {}), r({ type: 'MultiPoint', coordinates: e }, t, n);
		}
		function l(e, t, n) {
			return void 0 === n && (n = {}), r({ type: 'MultiPolygon', coordinates: e }, t, n);
		}
		function c(e, r) {
			void 0 === r && (r = 'kilometers');
			var n = t.factors[r];
			if (!n) throw new Error(r + ' units is invalid');
			return e * n;
		}
		function f(e, r) {
			void 0 === r && (r = 'kilometers');
			var n = t.factors[r];
			if (!n) throw new Error(r + ' units is invalid');
			return e / n;
		}
		function h(e) {
			return (180 * (e % (2 * Math.PI))) / Math.PI;
		}
		function d(e) {
			return !isNaN(e) && null !== e && !Array.isArray(e) && !/^\s*$/.test(e);
		}
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.earthRadius = 6371008.8),
			(t.factors = {
				centimeters: 100 * t.earthRadius,
				centimetres: 100 * t.earthRadius,
				degrees: t.earthRadius / 111325,
				feet: 3.28084 * t.earthRadius,
				inches: 39.37 * t.earthRadius,
				kilometers: t.earthRadius / 1e3,
				kilometres: t.earthRadius / 1e3,
				meters: t.earthRadius,
				metres: t.earthRadius,
				miles: t.earthRadius / 1609.344,
				millimeters: 1e3 * t.earthRadius,
				millimetres: 1e3 * t.earthRadius,
				nauticalmiles: t.earthRadius / 1852,
				radians: 1,
				yards: t.earthRadius / 1.0936,
			}),
			(t.unitsFactors = {
				centimeters: 100,
				centimetres: 100,
				degrees: 1 / 111325,
				feet: 3.28084,
				inches: 39.37,
				kilometers: 0.001,
				kilometres: 0.001,
				meters: 1,
				metres: 1,
				miles: 1 / 1609.344,
				millimeters: 1e3,
				millimetres: 1e3,
				nauticalmiles: 1 / 1852,
				radians: 1 / t.earthRadius,
				yards: 1 / 1.0936,
			}),
			(t.areaFactors = {
				acres: 247105e-9,
				centimeters: 1e4,
				centimetres: 1e4,
				feet: 10.763910417,
				inches: 1550.003100006,
				kilometers: 1e-6,
				kilometres: 1e-6,
				meters: 1,
				metres: 1,
				miles: 3.86e-7,
				millimeters: 1e6,
				millimetres: 1e6,
				yards: 1.195990046,
			}),
			(t.feature = r),
			(t.geometry = function(e, t, r) {
				switch (e) {
					case 'Point':
						return n(t).geometry;
					case 'LineString':
						return i(t).geometry;
					case 'Polygon':
						return o(t).geometry;
					case 'MultiPoint':
						return s(t).geometry;
					case 'MultiLineString':
						return u(t).geometry;
					case 'MultiPolygon':
						return l(t).geometry;
					default:
						throw new Error(e + ' is invalid');
				}
			}),
			(t.point = n),
			(t.points = function(e, t, r) {
				return (
					void 0 === r && (r = {}),
					a(
						e.map(function(e) {
							return n(e, t);
						}),
						r
					)
				);
			}),
			(t.polygon = o),
			(t.polygons = function(e, t, r) {
				return (
					void 0 === r && (r = {}),
					a(
						e.map(function(e) {
							return o(e, t);
						}),
						r
					)
				);
			}),
			(t.lineString = i),
			(t.lineStrings = function(e, t, r) {
				return (
					void 0 === r && (r = {}),
					a(
						e.map(function(e) {
							return i(e, t);
						}),
						r
					)
				);
			}),
			(t.featureCollection = a),
			(t.multiLineString = u),
			(t.multiPoint = s),
			(t.multiPolygon = l),
			(t.geometryCollection = function(e, t, n) {
				return void 0 === n && (n = {}), r({ type: 'GeometryCollection', geometries: e }, t, n);
			}),
			(t.round = function(e, t) {
				if ((void 0 === t && (t = 0), t && !(t >= 0))) throw new Error('precision must be a positive number');
				var r = Math.pow(10, t || 0);
				return Math.round(e * r) / r;
			}),
			(t.radiansToLength = c),
			(t.lengthToRadians = f),
			(t.lengthToDegrees = function(e, t) {
				return h(f(e, t));
			}),
			(t.bearingToAzimuth = function(e) {
				var t = e % 360;
				return t < 0 && (t += 360), t;
			}),
			(t.radiansToDegrees = h),
			(t.degreesToRadians = function(e) {
				return ((e % 360) * Math.PI) / 180;
			}),
			(t.convertLength = function(e, t, r) {
				if ((void 0 === t && (t = 'kilometers'), void 0 === r && (r = 'kilometers'), !(e >= 0)))
					throw new Error('length must be a positive number');
				return c(f(e, t), r);
			}),
			(t.convertArea = function(e, r, n) {
				if ((void 0 === r && (r = 'meters'), void 0 === n && (n = 'kilometers'), !(e >= 0)))
					throw new Error('area must be a positive number');
				var o = t.areaFactors[r];
				if (!o) throw new Error('invalid original units');
				var i = t.areaFactors[n];
				if (!i) throw new Error('invalid final units');
				return (e / o) * i;
			}),
			(t.isNumber = d),
			(t.isObject = function(e) {
				return !!e && e.constructor === Object;
			}),
			(t.validateBBox = function(e) {
				if (!e) throw new Error('bbox is required');
				if (!Array.isArray(e)) throw new Error('bbox must be an Array');
				if (4 !== e.length && 6 !== e.length) throw new Error('bbox must be an Array of 4 or 6 numbers');
				e.forEach(function(e) {
					if (!d(e)) throw new Error('bbox must only contain numbers');
				});
			}),
			(t.validateId = function(e) {
				if (!e) throw new Error('id is required');
				if (-1 === ['string', 'number'].indexOf(_typeof(e))) throw new Error('id must be a number or a string');
			}),
			(t.radians2degrees = function() {
				throw new Error('method has been renamed to `radiansToDegrees`');
			}),
			(t.degrees2radians = function() {
				throw new Error('method has been renamed to `degreesToRadians`');
			}),
			(t.distanceToDegrees = function() {
				throw new Error('method has been renamed to `lengthToDegrees`');
			}),
			(t.distanceToRadians = function() {
				throw new Error('method has been renamed to `lengthToRadians`');
			}),
			(t.radiansToDistance = function() {
				throw new Error('method has been renamed to `radiansToLength`');
			}),
			(t.bearingToAngle = function() {
				throw new Error('method has been renamed to `bearingToAzimuth`');
			}),
			(t.convertDistance = function() {
				throw new Error('method has been renamed to `convertLength`');
			});
	});
	t(b);
	b.earthRadius,
		b.factors,
		b.unitsFactors,
		b.areaFactors,
		b.feature,
		b.geometry,
		b.point,
		b.points,
		b.polygon,
		b.polygons,
		b.lineString,
		b.lineStrings,
		b.featureCollection,
		b.multiLineString,
		b.multiPoint,
		b.multiPolygon,
		b.geometryCollection,
		b.round,
		b.radiansToLength,
		b.lengthToRadians,
		b.lengthToDegrees,
		b.bearingToAzimuth,
		b.radiansToDegrees,
		b.degreesToRadians,
		b.convertLength,
		b.convertArea,
		b.isNumber,
		b.isObject,
		b.validateBBox,
		b.validateId,
		b.radians2degrees,
		b.degrees2radians,
		b.distanceToDegrees,
		b.distanceToRadians,
		b.radiansToDistance,
		b.bearingToAngle,
		b.convertDistance;
	var w = r(function(e, t) {
		function r(e, t, n) {
			if (null !== e)
				for (
					var o,
						i,
						a,
						u,
						s,
						l,
						c,
						f,
						h = 0,
						d = 0,
						g = e.type,
						m = 'FeatureCollection' === g,
						p = 'Feature' === g,
						y = m ? e.features.length : 1,
						v = 0;
					v < y;
					v++
				) {
					s = (f = !!(c = m ? e.features[v].geometry : p ? e.geometry : e) && 'GeometryCollection' === c.type)
						? c.geometries.length
						: 1;
					for (var b = 0; b < s; b++) {
						var w = 0,
							P = 0;
						if (null !== (u = f ? c.geometries[b] : c)) {
							l = u.coordinates;
							var M = u.type;
							switch (((h = !n || ('Polygon' !== M && 'MultiPolygon' !== M) ? 0 : 1), M)) {
								case null:
									break;
								case 'Point':
									if (!1 === t(l, d, v, w, P)) return !1;
									d++, w++;
									break;
								case 'LineString':
								case 'MultiPoint':
									for (o = 0; o < l.length; o++) {
										if (!1 === t(l[o], d, v, w, P)) return !1;
										d++, 'MultiPoint' === M && w++;
									}
									'LineString' === M && w++;
									break;
								case 'Polygon':
								case 'MultiLineString':
									for (o = 0; o < l.length; o++) {
										for (i = 0; i < l[o].length - h; i++) {
											if (!1 === t(l[o][i], d, v, w, P)) return !1;
											d++;
										}
										'MultiLineString' === M && w++, 'Polygon' === M && P++;
									}
									'Polygon' === M && w++;
									break;
								case 'MultiPolygon':
									for (o = 0; o < l.length; o++) {
										for (P = 0, i = 0; i < l[o].length; i++) {
											for (a = 0; a < l[o][i].length - h; a++) {
												if (!1 === t(l[o][i][a], d, v, w, P)) return !1;
												d++;
											}
											P++;
										}
										w++;
									}
									break;
								case 'GeometryCollection':
									for (o = 0; o < u.geometries.length; o++)
										if (!1 === r(u.geometries[o], t, n)) return !1;
									break;
								default:
									throw new Error('Unknown Geometry Type');
							}
						}
					}
				}
		}
		function n(e, t) {
			var r;
			switch (e.type) {
				case 'FeatureCollection':
					for (r = 0; r < e.features.length && !1 !== t(e.features[r].properties, r); r++);
					break;
				case 'Feature':
					t(e.properties, 0);
			}
		}
		function o(e, t) {
			if ('Feature' === e.type) t(e, 0);
			else if ('FeatureCollection' === e.type)
				for (var r = 0; r < e.features.length && !1 !== t(e.features[r], r); r++);
		}
		function i(e, t) {
			var r,
				n,
				o,
				i,
				a,
				u,
				s,
				l,
				c,
				f,
				h = 0,
				d = 'FeatureCollection' === e.type,
				g = 'Feature' === e.type,
				m = d ? e.features.length : 1;
			for (r = 0; r < m; r++) {
				for (
					u = d ? e.features[r].geometry : g ? e.geometry : e,
						l = d ? e.features[r].properties : g ? e.properties : {},
						c = d ? e.features[r].bbox : g ? e.bbox : void 0,
						f = d ? e.features[r].id : g ? e.id : void 0,
						a = (s = !!u && 'GeometryCollection' === u.type) ? u.geometries.length : 1,
						o = 0;
					o < a;
					o++
				)
					if (null !== (i = s ? u.geometries[o] : u))
						switch (i.type) {
							case 'Point':
							case 'LineString':
							case 'MultiPoint':
							case 'Polygon':
							case 'MultiLineString':
							case 'MultiPolygon':
								if (!1 === t(i, h, l, c, f)) return !1;
								break;
							case 'GeometryCollection':
								for (n = 0; n < i.geometries.length; n++)
									if (!1 === t(i.geometries[n], h, l, c, f)) return !1;
								break;
							default:
								throw new Error('Unknown Geometry Type');
						}
					else if (!1 === t(null, h, l, c, f)) return !1;
				h++;
			}
		}
		function a(e, t) {
			i(e, function(e, r, n, o, i) {
				var a,
					u = null === e ? null : e.type;
				switch (u) {
					case null:
					case 'Point':
					case 'LineString':
					case 'Polygon':
						return !1 !== t(b.feature(e, n, { bbox: o, id: i }), r, 0) && void 0;
				}
				switch (u) {
					case 'MultiPoint':
						a = 'Point';
						break;
					case 'MultiLineString':
						a = 'LineString';
						break;
					case 'MultiPolygon':
						a = 'Polygon';
				}
				for (var s = 0; s < e.coordinates.length; s++) {
					var l = { type: a, coordinates: e.coordinates[s] };
					if (!1 === t(b.feature(l, n), r, s)) return !1;
				}
			});
		}
		function u(e, t) {
			a(e, function(e, n, o) {
				var i = 0;
				if (e.geometry) {
					var a = e.geometry.type;
					if ('Point' !== a && 'MultiPoint' !== a) {
						var u,
							s = 0,
							l = 0,
							c = 0;
						return (
							!1 !==
								r(e, function(r, a, f, h, d) {
									if (void 0 === u || n > s || h > l || d > c)
										return (u = r), (s = n), (l = h), (c = d), void (i = 0);
									var g = b.lineString([u, r], e.properties);
									if (!1 === t(g, n, o, d, i)) return !1;
									i++, (u = r);
								}) && void 0
						);
					}
				}
			});
		}
		function s(e, t) {
			if (!e) throw new Error('geojson is required');
			a(e, function(e, r, n) {
				if (null !== e.geometry) {
					var o = e.geometry.type,
						i = e.geometry.coordinates;
					switch (o) {
						case 'LineString':
							if (!1 === t(e, r, n, 0, 0)) return !1;
							break;
						case 'Polygon':
							for (var a = 0; a < i.length; a++)
								if (!1 === t(b.lineString(i[a], e.properties), r, n, a)) return !1;
					}
				}
			});
		}
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.coordEach = r),
			(t.coordReduce = function(e, t, n, o) {
				var i = n;
				return (
					r(
						e,
						function(e, r, o, a, u) {
							i = 0 === r && void 0 === n ? e : t(i, e, r, o, a, u);
						},
						o
					),
					i
				);
			}),
			(t.propEach = n),
			(t.propReduce = function(e, t, r) {
				var o = r;
				return (
					n(e, function(e, n) {
						o = 0 === n && void 0 === r ? e : t(o, e, n);
					}),
					o
				);
			}),
			(t.featureEach = o),
			(t.featureReduce = function(e, t, r) {
				var n = r;
				return (
					o(e, function(e, o) {
						n = 0 === o && void 0 === r ? e : t(n, e, o);
					}),
					n
				);
			}),
			(t.coordAll = function(e) {
				var t = [];
				return (
					r(e, function(e) {
						t.push(e);
					}),
					t
				);
			}),
			(t.geomEach = i),
			(t.geomReduce = function(e, t, r) {
				var n = r;
				return (
					i(e, function(e, o, i, a, u) {
						n = 0 === o && void 0 === r ? e : t(n, e, o, i, a, u);
					}),
					n
				);
			}),
			(t.flattenEach = a),
			(t.flattenReduce = function(e, t, r) {
				var n = r;
				return (
					a(e, function(e, o, i) {
						n = 0 === o && 0 === i && void 0 === r ? e : t(n, e, o, i);
					}),
					n
				);
			}),
			(t.segmentEach = u),
			(t.segmentReduce = function(e, t, r) {
				var n = r,
					o = !1;
				return (
					u(e, function(e, i, a, u, s) {
						(n = !1 === o && void 0 === r ? e : t(n, e, i, a, u, s)), (o = !0);
					}),
					n
				);
			}),
			(t.lineEach = s),
			(t.lineReduce = function(e, t, r) {
				var n = r;
				return (
					s(e, function(e, o, i, a) {
						n = 0 === o && void 0 === r ? e : t(n, e, o, i, a);
					}),
					n
				);
			}),
			(t.findSegment = function(e, t) {
				if (((t = t || {}), !b.isObject(t))) throw new Error('options is invalid');
				var r,
					n = t.featureIndex || 0,
					o = t.multiFeatureIndex || 0,
					i = t.geometryIndex || 0,
					a = t.segmentIndex || 0,
					u = t.properties;
				switch (e.type) {
					case 'FeatureCollection':
						n < 0 && (n = e.features.length + n),
							(u = u || e.features[n].properties),
							(r = e.features[n].geometry);
						break;
					case 'Feature':
						(u = u || e.properties), (r = e.geometry);
						break;
					case 'Point':
					case 'MultiPoint':
						return null;
					case 'LineString':
					case 'Polygon':
					case 'MultiLineString':
					case 'MultiPolygon':
						r = e;
						break;
					default:
						throw new Error('geojson is invalid');
				}
				if (null === r) return null;
				var s = r.coordinates;
				switch (r.type) {
					case 'Point':
					case 'MultiPoint':
						return null;
					case 'LineString':
						return a < 0 && (a = s.length + a - 1), b.lineString([s[a], s[a + 1]], u, t);
					case 'Polygon':
						return (
							i < 0 && (i = s.length + i),
							a < 0 && (a = s[i].length + a - 1),
							b.lineString([s[i][a], s[i][a + 1]], u, t)
						);
					case 'MultiLineString':
						return (
							o < 0 && (o = s.length + o),
							a < 0 && (a = s[o].length + a - 1),
							b.lineString([s[o][a], s[o][a + 1]], u, t)
						);
					case 'MultiPolygon':
						return (
							o < 0 && (o = s.length + o),
							i < 0 && (i = s[o].length + i),
							a < 0 && (a = s[o][i].length - a - 1),
							b.lineString([s[o][i][a], s[o][i][a + 1]], u, t)
						);
				}
				throw new Error('geojson is invalid');
			}),
			(t.findPoint = function(e, t) {
				if (((t = t || {}), !b.isObject(t))) throw new Error('options is invalid');
				var r,
					n = t.featureIndex || 0,
					o = t.multiFeatureIndex || 0,
					i = t.geometryIndex || 0,
					a = t.coordIndex || 0,
					u = t.properties;
				switch (e.type) {
					case 'FeatureCollection':
						n < 0 && (n = e.features.length + n),
							(u = u || e.features[n].properties),
							(r = e.features[n].geometry);
						break;
					case 'Feature':
						(u = u || e.properties), (r = e.geometry);
						break;
					case 'Point':
					case 'MultiPoint':
						return null;
					case 'LineString':
					case 'Polygon':
					case 'MultiLineString':
					case 'MultiPolygon':
						r = e;
						break;
					default:
						throw new Error('geojson is invalid');
				}
				if (null === r) return null;
				var s = r.coordinates;
				switch (r.type) {
					case 'Point':
						return b.point(s, u, t);
					case 'MultiPoint':
						return o < 0 && (o = s.length + o), b.point(s[o], u, t);
					case 'LineString':
						return a < 0 && (a = s.length + a), b.point(s[a], u, t);
					case 'Polygon':
						return i < 0 && (i = s.length + i), a < 0 && (a = s[i].length + a), b.point(s[i][a], u, t);
					case 'MultiLineString':
						return o < 0 && (o = s.length + o), a < 0 && (a = s[o].length + a), b.point(s[o][a], u, t);
					case 'MultiPolygon':
						return (
							o < 0 && (o = s.length + o),
							i < 0 && (i = s[o].length + i),
							a < 0 && (a = s[o][i].length - a),
							b.point(s[o][i][a], u, t)
						);
				}
				throw new Error('geojson is invalid');
			});
	});
	t(w);
	w.coordEach,
		w.coordReduce,
		w.propEach,
		w.propReduce,
		w.featureEach,
		w.featureReduce,
		w.coordAll,
		w.geomEach,
		w.geomReduce,
		w.flattenEach,
		w.flattenReduce,
		w.segmentEach,
		w.segmentReduce,
		w.lineEach,
		w.lineReduce,
		w.findSegment,
		w.findPoint;
	var P = r(function(e, t) {
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.default = function(e) {
				var t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
				return (
					w.coordEach(e, function(e) {
						t[0] > e[0] && (t[0] = e[0]),
							t[1] > e[1] && (t[1] = e[1]),
							t[2] < e[0] && (t[2] = e[0]),
							t[3] < e[1] && (t[3] = e[1]);
					}),
					t
				);
			});
	});
	t(P);
	var M = r(function(e, t) {
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.getCoord = function(e) {
				if (!e) throw new Error('coord is required');
				if (!Array.isArray(e)) {
					if ('Feature' === e.type && null !== e.geometry && 'Point' === e.geometry.type)
						return e.geometry.coordinates;
					if ('Point' === e.type) return e.coordinates;
				}
				if (Array.isArray(e) && e.length >= 2 && !Array.isArray(e[0]) && !Array.isArray(e[1])) return e;
				throw new Error('coord must be GeoJSON Point or an Array of numbers');
			}),
			(t.getCoords = function(e) {
				if (Array.isArray(e)) return e;
				if ('Feature' === e.type) {
					if (null !== e.geometry) return e.geometry.coordinates;
				} else if (e.coordinates) return e.coordinates;
				throw new Error('coords must be GeoJSON Feature, Geometry Object or an Array');
			}),
			(t.containsNumber = function e(t) {
				if (t.length > 1 && b.isNumber(t[0]) && b.isNumber(t[1])) return !0;
				if (Array.isArray(t[0]) && t[0].length) return e(t[0]);
				throw new Error('coordinates must only contain numbers');
			}),
			(t.geojsonType = function(e, t, r) {
				if (!t || !r) throw new Error('type and name required');
				if (!e || e.type !== t)
					throw new Error('Invalid input to ' + r + ': must be a ' + t + ', given ' + e.type);
			}),
			(t.featureOf = function(e, t, r) {
				if (!e) throw new Error('No feature passed');
				if (!r) throw new Error('.featureOf() requires a name');
				if (!e || 'Feature' !== e.type || !e.geometry)
					throw new Error('Invalid input to ' + r + ', Feature with geometry required');
				if (!e.geometry || e.geometry.type !== t)
					throw new Error('Invalid input to ' + r + ': must be a ' + t + ', given ' + e.geometry.type);
			}),
			(t.collectionOf = function(e, t, r) {
				if (!e) throw new Error('No featureCollection passed');
				if (!r) throw new Error('.collectionOf() requires a name');
				if (!e || 'FeatureCollection' !== e.type)
					throw new Error('Invalid input to ' + r + ', FeatureCollection required');
				for (var n = 0, o = e.features; n < o.length; n++) {
					var i = o[n];
					if (!i || 'Feature' !== i.type || !i.geometry)
						throw new Error('Invalid input to ' + r + ', Feature with geometry required');
					if (!i.geometry || i.geometry.type !== t)
						throw new Error('Invalid input to ' + r + ': must be a ' + t + ', given ' + i.geometry.type);
				}
			}),
			(t.getGeom = function(e) {
				return 'Feature' === e.type ? e.geometry : e;
			}),
			(t.getType = function(e, t) {
				return 'FeatureCollection' === e.type
					? 'FeatureCollection'
					: 'GeometryCollection' === e.type
					? 'GeometryCollection'
					: 'Feature' === e.type && null !== e.geometry
					? e.geometry.type
					: e.type;
			});
	});
	t(M);
	M.getCoord, M.getCoords, M.containsNumber, M.geojsonType, M.featureOf, M.collectionOf, M.getGeom, M.getType;
	var x = r(function(e, t) {
		function r(e, t, r) {
			var n = !1;
			t[0][0] === t[t.length - 1][0] && t[0][1] === t[t.length - 1][1] && (t = t.slice(0, t.length - 1));
			for (var o = 0, i = t.length - 1; o < t.length; i = o++) {
				var a = t[o][0],
					u = t[o][1],
					s = t[i][0],
					l = t[i][1];
				if (
					e[1] * (a - s) + u * (s - e[0]) + l * (e[0] - a) == 0 &&
					(a - e[0]) * (s - e[0]) <= 0 &&
					(u - e[1]) * (l - e[1]) <= 0
				)
					return !r;
				u > e[1] != l > e[1] && e[0] < ((s - a) * (e[1] - u)) / (l - u) + a && (n = !n);
			}
			return n;
		}
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.default = function(e, t, n) {
				if ((void 0 === n && (n = {}), !e)) throw new Error('point is required');
				if (!t) throw new Error('polygon is required');
				var o = M.getCoord(e),
					i = M.getGeom(t),
					a = i.type,
					u = t.bbox,
					s = i.coordinates;
				if (
					u &&
					!1 ===
						(function(e, t) {
							return t[0] <= e[0] && t[1] <= e[1] && t[2] >= e[0] && t[3] >= e[1];
						})(o, u)
				)
					return !1;
				'Polygon' === a && (s = [s]);
				for (var l = !1, c = 0; c < s.length && !l; c++)
					if (r(o, s[c][0], n.ignoreBoundary)) {
						for (var f = !1, h = 1; h < s[c].length && !f; )
							r(o, s[c][h], !n.ignoreBoundary) && (f = !0), h++;
						f || (l = !0);
					}
				return l;
			});
	});
	t(x);
	var E = r(function(e, t) {
		function r(e, t, r, n) {
			var o = r[0],
				i = r[1],
				a = e[0],
				u = e[1],
				s = t[0],
				l = t[1],
				c = s - a,
				f = l - u;
			return (
				0 == (r[0] - a) * f - (r[1] - u) * c &&
				(n
					? 'start' === n
						? Math.abs(c) >= Math.abs(f)
							? c > 0
								? a < o && o <= s
								: s <= o && o < a
							: f > 0
							? u < i && i <= l
							: l <= i && i < u
						: 'end' === n
						? Math.abs(c) >= Math.abs(f)
							? c > 0
								? a <= o && o < s
								: s < o && o <= a
							: f > 0
							? u <= i && i < l
							: l < i && i <= u
						: 'both' === n &&
						  (Math.abs(c) >= Math.abs(f)
								? c > 0
									? a < o && o < s
									: s < o && o < a
								: f > 0
								? u < i && i < l
								: l < i && i < u)
					: Math.abs(c) >= Math.abs(f)
					? c > 0
						? a <= o && o <= s
						: s <= o && o <= a
					: f > 0
					? u <= i && i <= l
					: l <= i && i <= u)
			);
		}
		Object.defineProperty(t, '__esModule', { value: !0 }),
			(t.default = function(e, t, n) {
				void 0 === n && (n = {});
				for (var o = M.getCoord(e), i = M.getCoords(t), a = 0; a < i.length - 1; a++) {
					var u = !1;
					if (
						(n.ignoreEndVertices &&
							(0 === a && (u = 'start'),
							a === i.length - 2 && (u = 'end'),
							0 === a && a + 1 === i.length - 1 && (u = 'both')),
						r(i[a], i[a + 1], o, u))
					)
						return !0;
				}
				return !1;
			});
	});
	t(E);
	var _ = r(function(t, r) {
		var n =
			(e && e.__importDefault) ||
			function(e) {
				return e && e.__esModule ? e : { default: e };
			};
		Object.defineProperty(r, '__esModule', { value: !0 });
		var o = n(P),
			i = n(x),
			a = n(E);
		function u(e, t) {
			var r,
				n = !1;
			for (r = 0; r < e.coordinates.length; r++)
				if (m(e.coordinates[r], t.coordinates)) {
					n = !0;
					break;
				}
			return n;
		}
		function s(e, t) {
			for (var r = 0, n = t.coordinates; r < n.length; r++) {
				for (var o = n[r], i = !1, a = 0, u = e.coordinates; a < u.length; a++) {
					if (m(o, u[a])) {
						i = !0;
						break;
					}
				}
				if (!i) return !1;
			}
			return !0;
		}
		function l(e, t) {
			for (var r = !1, n = 0, o = t.coordinates; n < o.length; n++) {
				var i = o[n];
				if ((a.default(i, e, { ignoreEndVertices: !0 }) && (r = !0), !a.default(i, e))) return !1;
			}
			return !!r;
		}
		function c(e, t) {
			for (var r = 0, n = t.coordinates; r < n.length; r++) {
				var o = n[r];
				if (!i.default(o, e, { ignoreBoundary: !0 })) return !1;
			}
			return !0;
		}
		function f(e, t) {
			for (var r = !1, n = 0, o = t.coordinates; n < o.length; n++) {
				var i = o[n];
				if (
					(a.default({ type: 'Point', coordinates: i }, e, { ignoreEndVertices: !0 }) && (r = !0),
					!a.default({ type: 'Point', coordinates: i }, e, { ignoreEndVertices: !1 }))
				)
					return !1;
			}
			return r;
		}
		function h(e, t) {
			var r = !1,
				n = 0;
			if (!g(o.default(e), o.default(t))) return !1;
			for (; n < t.coordinates.length - 1; n++) {
				var a = p(t.coordinates[n], t.coordinates[n + 1]);
				if (i.default({ type: 'Point', coordinates: a }, e, { ignoreBoundary: !0 })) {
					r = !0;
					break;
				}
			}
			return r;
		}
		function d(e, t) {
			if ('Feature' === e.type && null === e.geometry) return !1;
			if ('Feature' === t.type && null === t.geometry) return !1;
			if (!g(o.default(e), o.default(t))) return !1;
			for (var r = 0, n = M.getGeom(t).coordinates; r < n.length; r++)
				for (var a = 0, u = n[r]; a < u.length; a++) {
					var s = u[a];
					if (!i.default(s, e)) return !1;
				}
			return !0;
		}
		function g(e, t) {
			return !(e[0] > t[0]) && !(e[2] < t[2]) && !(e[1] > t[1]) && !(e[3] < t[3]);
		}
		function m(e, t) {
			return e[0] === t[0] && e[1] === t[1];
		}
		function p(e, t) {
			return [(e[0] + t[0]) / 2, (e[1] + t[1]) / 2];
		}
		(r.default = function(e, t) {
			var r = M.getGeom(e),
				n = M.getGeom(t),
				o = M.getType(e),
				g = M.getType(t),
				p = M.getCoords(e),
				y = M.getCoords(t);
			switch (o) {
				case 'Point':
					switch (g) {
						case 'Point':
							return m(p, y);
						default:
							throw new Error('feature2 ' + g + ' geometry not supported');
					}
				case 'MultiPoint':
					switch (g) {
						case 'Point':
							return u(r, n);
						case 'MultiPoint':
							return s(r, n);
						default:
							throw new Error('feature2 ' + g + ' geometry not supported');
					}
				case 'LineString':
					switch (g) {
						case 'Point':
							return a.default(n, r, { ignoreEndVertices: !0 });
						case 'LineString':
							return f(r, n);
						case 'MultiPoint':
							return l(r, n);
						default:
							throw new Error('feature2 ' + g + ' geometry not supported');
					}
				case 'Polygon':
					switch (g) {
						case 'Point':
							return i.default(n, r, { ignoreBoundary: !0 });
						case 'LineString':
							return h(r, n);
						case 'Polygon':
							return d(r, n);
						case 'MultiPoint':
							return c(r, n);
						default:
							throw new Error('feature2 ' + g + ' geometry not supported');
					}
				default:
					throw new Error('feature1 ' + o + ' geometry not supported');
			}
		}),
			(r.isPointInMultiPoint = u),
			(r.isMultiPointInMultiPoint = s),
			(r.isMultiPointOnLine = l),
			(r.isMultiPointInPoly = c),
			(r.isLineOnLine = f),
			(r.isLineInPoly = h),
			(r.isPolyInPoly = d),
			(r.doBBoxOverlap = g),
			(r.compareCoords = m),
			(r.getMidpoint = p);
	});
	t(_);
	_.isPointInMultiPoint,
		_.isMultiPointInMultiPoint,
		_.isMultiPointOnLine,
		_.isMultiPointInPoly,
		_.isLineOnLine,
		_.isLineInPoly,
		_.isPolyInPoly,
		_.doBBoxOverlap,
		_.compareCoords,
		_.getMidpoint;
	var L = (function() {
			function e(t, r) {
				_classCallCheck(this, e),
					(r = 'object' === _typeof(r) ? r : {}),
					(this.pointsList = !0 === r.ignorePoints ? void 0 : []),
					(this.linesList = !0 === r.ignoreLines ? void 0 : []),
					(this.polygonsList = !0 === r.ignorePolygons ? void 0 : []),
					this._loadGeneric(t);
			}
			return (
				_createClass(e, [
					{
						key: '_loadGeneric',
						value: function(e, t) {
							var r = this;
							if (void 0 !== this.pointsList)
								switch (e.type) {
									case 'Point':
										return this._loadPoint(e.coordinates, t);
									case 'MultiPoint':
										return e.coordinates.forEach(function(e) {
											return r._loadPoint(e, t);
										});
								}
							if (void 0 !== this.linesList)
								switch (e.type) {
									case 'LineString':
										return this._loadLine(e.coordinates, t);
									case 'MultiLineString':
										return e.coordinates.forEach(function(e) {
											return r._loadLine(e, t);
										});
								}
							if (void 0 !== this.polygonsList)
								switch (e.type) {
									case 'Polygon':
										return this._loadPolygon(e.coordinates, t);
									case 'MultiPolygon':
										return e.coordinates.forEach(function(e) {
											return r._loadPolygon(e, t);
										});
								}
							switch (e.type) {
								case 'Feature':
									return this._loadGeneric(e.geometry, e.properties);
								case 'FeatureCollection':
									return e.features.forEach(function(e) {
										return r._loadGeneric(e.geometry, e.properties);
									});
								case 'GeometryCollection':
									return e.geometries.forEach(function(e) {
										return r._loadGeneric(e, t);
									});
							}
						},
					},
					{
						key: '_loadPoint',
						value: function(e, t) {
							this.pointsList.push({
								type: 'Feature',
								geometry: { type: 'Point', coordinates: e },
								properties: t,
							});
						},
					},
					{
						key: '_loadLine',
						value: function(e, t) {
							this.linesList.push({
								type: 'Feature',
								geometry: { type: 'LineString', coordinates: e },
								properties: t,
							});
						},
					},
					{
						key: '_loadPolygon',
						value: function(e, t) {
							this.polygonsList.push({
								type: 'Feature',
								geometry: { type: 'Polygon', coordinates: e },
								properties: t,
							});
						},
					},
					{
						key: 'points',
						get: function() {
							return { type: 'FeatureCollection', features: this.pointsList || [] };
						},
					},
					{
						key: 'lines',
						get: function() {
							return { type: 'FeatureCollection', features: this.linesList || [] };
						},
					},
					{
						key: 'polygons',
						get: function() {
							return { type: 'FeatureCollection', features: this.polygonsList || [] };
						},
					},
				]),
				e
			);
		})(),
		S = P.default,
		k = _.default,
		C = 'Point',
		F = 'LineString',
		B = 'Polygon';
	return (function() {
		function e(t, r) {
			_classCallCheck(this, e), (r = 'object' === _typeof(r) ? r : {});
			var n = new L(t, r);
			(this.D = new Array(3)),
				(this.D[0] = { list: n.points.features, bboxs: null, lookup: null }),
				(this.D[1] = { list: n.lines.features, bboxs: null, lookup: null }),
				(this.D[2] = { list: n.polygons.features, bboxs: null, lookup: null });
			for (var i = 0; i < 3; i++) {
				var a = this.D[i];
				if (a.list.length > 0) {
					(a.bboxs = new Array(a.list.length)), (a.lookup = o());
					for (var u = a.list, s = a.bboxs, l = a.lookup, c = 0, f = u.length; c < f; c++) {
						var h = S(u[c]);
						s[c] = { minX: h[0], minY: h[1], maxX: h[2], maxY: h[3], id: c };
					}
					l.load(s);
				}
			}
		}
		return (
			_createClass(e, [
				{
					key: 'forEachCotainer',
					value: function(e, t, r) {
						(t = 'object' === _typeof(t) ? t : {}), (r = 'function' == typeof r ? r : function() {});
						for (
							var n = 0,
								o = (function(e) {
									switch (e.type) {
										case C:
											return 0;
										case F:
											return 1;
										case B:
											return 2;
										default:
											throw new TypeError(
												'Unsupported GeoJSON type. Use one of: Point, LineString, Polygon'
											);
									}
								})(e),
								i = [t.ignorePoints, t.ignoreLines, t.ignorePolygons],
								a = o;
							a < 3;
							a++
						)
							if (!0 !== i[a]) {
								var u = this.D[a];
								if (null !== u.lookup)
									for (
										var s = S(e),
											l = u.lookup.search({ minX: s[0], minY: s[1], maxX: s[2], maxY: s[3] }),
											c = 0,
											f = l.length;
										c < f;
										c++
									) {
										var h = u.list[l[c].id];
										if (k(h, e) && (r(h, n), n++, t.limit > 0 && t.limit === n)) return n;
									}
							}
						return n;
					},
				},
				{
					key: 'getContainers',
					value: function(e, t) {
						t = 'object' === _typeof(t) ? t : {};
						var r = [];
						return (
							this.forEachCotainer(e, t, function(e) {
								return r.push(e);
							}),
							{ type: 'featureCollection', features: r }
						);
					},
				},
				{
					key: 'hasContainers',
					value: function(e, t) {
						return ((t = 'object' === _typeof(t) ? t : {}).limit = 1), 1 === this.forEachCotainer(e, t);
					},
				},
				{
					key: 'countContainers',
					value: function(e, t) {
						return (t = 'object' === _typeof(t) ? t : {}), this.forEachCotainer(e, t);
					},
				},
			]),
			e
		);
	})();
})();
